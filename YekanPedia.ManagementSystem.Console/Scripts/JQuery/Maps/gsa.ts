/// <reference path="google.maps.d.ts" />   namespace gsa.bcl {     //******************************** Error Handler  ***************************************//     abstract class MinError {         constructor(public code: number, public name: string) { }         displayError(message: string) {             var prefix = '[' + (name ? name + ':' : '') + this.code + '] ', finalmessage;             finalmessage = prefix + message.replace(/\{\d+\}/g, function (match) {                 return match;             });             finalmessage = finalmessage + '\nhttp://cms.yekanPedia.org/map/51205/' + (this.name ? this.name + '/' : '') + this.code;             return finalmessage         }     }     export class MapOptionException extends MinError implements Error {         name: string = 'MapOption';         constructor(public code: number, public message: string = '') {             super(code, name);         }         toString() {             if (this.message == '') {                 switch (this.code) {                     case 40401: { this.message = "mapElement not found !"; break; }                     case 40405: { this.message = "the posiotion field parameter is not set !"; break; }                     case 50001: { this.message = "the posiotion field of MarkersOptions parameter is not set !"; break; }                     default: { this.message = "unhandled Exception!"; break; }                 }             }             return super.displayError(this.message);         }     }     export class RemoteServiceException extends MinError implements Error {         name: string = 'RemoteService';         constructor(public code: number, public message: string = '') {             super(code, name);         }         toString() {             return super.displayError(this.message);         }     }  } namespace gsa.util {      export class TypeCasting {         public static toGoogleMapsZoomControlStyle(zoomControlStyle: gsa.maps.ZoomControlStyle): google.maps.ZoomControlStyle {             switch (zoomControlStyle) {                 case gsa.maps.ZoomControlStyle.DEFAULT: { return google.maps.ZoomControlStyle.DEFAULT; }                 case gsa.maps.ZoomControlStyle.LARGE: { return google.maps.ZoomControlStyle.LARGE; }                 case gsa.maps.ZoomControlStyle.SMALL: { return google.maps.ZoomControlStyle.SMALL; }                 default: { return google.maps.ZoomControlStyle.DEFAULT; }             }         }         public static toGoogleMapsControlPosition(controlPosition: gsa.maps.ControlPosition): google.maps.ControlPosition {             switch (controlPosition) {                 case gsa.maps.ControlPosition.BOTTOM_CENTER: { return google.maps.ControlPosition.BOTTOM_CENTER; }                 case gsa.maps.ControlPosition.BOTTOM_LEFT: { return google.maps.ControlPosition.BOTTOM_LEFT; }                 case gsa.maps.ControlPosition.BOTTOM_RIGHT: { return google.maps.ControlPosition.BOTTOM_RIGHT; }                 case gsa.maps.ControlPosition.LEFT_BOTTOM: { return google.maps.ControlPosition.LEFT_BOTTOM; }                 case gsa.maps.ControlPosition.LEFT_CENTER: { return google.maps.ControlPosition.LEFT_CENTER; }                 case gsa.maps.ControlPosition.LEFT_TOP: { return google.maps.ControlPosition.LEFT_TOP; }                 case gsa.maps.ControlPosition.RIGHT_BOTTOM: { return google.maps.ControlPosition.RIGHT_BOTTOM; }                 case gsa.maps.ControlPosition.RIGHT_CENTER: { return google.maps.ControlPosition.RIGHT_CENTER; }                 case gsa.maps.ControlPosition.RIGHT_TOP: { return google.maps.ControlPosition.RIGHT_TOP; }                 case gsa.maps.ControlPosition.TOP_CENTER: { return google.maps.ControlPosition.TOP_CENTER; }                 case gsa.maps.ControlPosition.TOP_LEFT: { return google.maps.ControlPosition.TOP_LEFT; }                 case gsa.maps.ControlPosition.TOP_RIGHT: { return google.maps.ControlPosition.TOP_RIGHT; }                 default: { return google.maps.ControlPosition.BOTTOM_LEFT; }             }         }         public static toGoogleMapsMapTypeId(mapTypeId: gsa.maps.MapTypeId): google.maps.MapTypeId {             switch (mapTypeId) {                 case gsa.maps.MapTypeId.HYBRID: { return google.maps.MapTypeId.HYBRID; }                 case gsa.maps.MapTypeId.ROADMAP: { return google.maps.MapTypeId.ROADMAP; }                 case gsa.maps.MapTypeId.SATELLITE: { return google.maps.MapTypeId.SATELLITE; }                 case gsa.maps.MapTypeId.TERRAIN: { return google.maps.MapTypeId.TERRAIN; }                  default: { return google.maps.MapTypeId.ROADMAP; }             }         }         public static toGoogleMapsLatLngObject(point: gsa.maps.LatLng): google.maps.LatLng {             return new google.maps.LatLng(point.lat, point.lng)         }     }     export class FunctionUtility {         public static isFunction(fn: any): boolean {             var getType = {};             return fn && getType.toString.call(fn) === '[object Function]';         }     }     /**     * String Interpolation for Templates Info Window     */     export class StringInterpolation {         constructor(private template: any) { }         public render(data: any): string {             var delimiter: string = "{{}}",                 regex: any,                 lDel: string,                 rDel: string,                 delLen: number,                 lDelLen: number,                 regexEscape: string = "/([$\^\\\/()|?+*\[\]{}.\-])/g";             delLen = delimiter.length;             lDelLen = Math.ceil(delLen / 2);             lDel = delimiter.substr(0, lDelLen).replace(regexEscape, "\\$1");             rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, "\\$1") || lDel;             regex = new RegExp(lDel + "[^" + lDel + rDel + "]+" + rDel, "g");             return this.template.replace(regex, function (placeholder) {                 var key = placeholder.slice(lDelLen, -lDelLen),                     keyParts = key.split("."),                     val,                     i = 0,                     len = keyParts.length;                  if (key in data) {                     val = data[key];                 }                 else {                     val = data;                     for (; i < len; i++) {                         if (keyParts[i] in val) {                             val = val[keyParts[i]];                         } else {                             return placeholder;                         }                     }                 }                 return val;             });         }         public getTemplate(): any { return this.template; }      }         /**     * singletone class for Url Helper     */     export class UrlHelper {         private static _instance: UrlHelper = new UrlHelper();         constructor() {             if (UrlHelper._instance) {                 throw new Error("Error: Instantiation failed: Use UrlHelper.getInstance() instead of new.");             }             UrlHelper._instance = this;         }         public static getInstance(): UrlHelper {             return UrlHelper._instance;         }         public getMyLocationMarkerIcon(): string {             return "http://cms.yekanPedia.org/Content/Images/Map/MyLocationMarkerIcon.png";         }         public getMarkers(queryString: string): string {             return "http://cms.yekanPedia.org/Content/Images/Map/" + queryString;         }     } } namespace gsa.net {     export class RemoteService {         private static FailureProxyCallback(context, arg) {             throw new gsa.bcl.MapOptionException(60001, arg);         }         public static SendRequest(requestArgs: JQueryAjaxSettings) {             var self = this;             requestArgs.error = function (arg) {                 self.FailureProxyCallback(this, arg)             };             return $.ajax(requestArgs);         };     }  } namespace gsa.maps {     import bcl = gsa.bcl;     /**       * MapTypeId enum defiend all available type map       */     export enum MapTypeId {         HYBRID,         ROADMAP,         SATELLITE,         TERRAIN     }     /**      * ControlPosition enum defiend position of all element on map such as textsearch,zoom control      */     export enum ControlPosition {         BOTTOM_CENTER,         BOTTOM_LEFT,         BOTTOM_RIGHT,         LEFT_BOTTOM,         LEFT_CENTER,         LEFT_TOP,         RIGHT_BOTTOM,         RIGHT_CENTER,         RIGHT_TOP,         TOP_CENTER,         TOP_LEFT,         TOP_RIGHT     }     export enum ZoomControlStyle {         DEFAULT,         LARGE,         SMALL     }     export enum Animation {         BOUNCE,         DROP     }      export interface KeyOption {         key: string;         template: () => string;         className: string;     }     export class KeyStore {         static Users: KeyOption = { key: "Users", template: () => { return TemplateManagment.defaulAgency(); }, className: "blue" };         static Student: KeyOption = { key: "Student", template: () => { return TemplateManagment.defaulAgency(); }, className: "yellow" };          public static getKey(key: string): KeyOption {             if (key == "Namayandegan") {                 return this.Users;             }             return this.Student;         }     }      /**      *       */     export class MapOption {         keys: Array<KeyOption>;         mapElement: string = "mapElement";         centerLatitude: number = 35.696111;                 //Center point View Of Map         centerLongitude: number = 51.423055999999995;       //Center point View Of Map         zoom: number = 14;         mapTypeId: gsa.maps.MapTypeId = gsa.maps.MapTypeId.ROADMAP;         zoomControl: boolean = true;         zoomControlStyle: ZoomControlStyle = ZoomControlStyle.DEFAULT;         zoomControlPosition: ControlPosition = ControlPosition.LEFT_BOTTOM;         setPointable: boolean = false;         setPointTemplate: string = 'برای بروز رسانی منطقه جغرافیایی خود بر روی دکمه ثبت کلیک نمایید';         public onSetPoint: (point: LatLng) => void;         public onStart: () => void;         public onError: (message?: any) => void;         public onComplete: () => void;          public findIndexKey(key: string): number {             for (var item in this.keys) {                 if (this.keys[item].key == key) {                     return item;                 }             }             return -1;         }     }     export class Map {         private _mapObject: google.maps.Map;         constructor(private _mapOption: MapOption = new MapOption()) {          }         public load(): Markers {             try {                 maps.CacheMarkers.getInstance().resetCache();                 var $mapElement = document.getElementById(this._mapOption.mapElement);                 if ($mapElement == null)                     throw new bcl.MapOptionException(40401, "#" + this._mapOption.mapElement + " element not found !");                 if (gsa.util.FunctionUtility.isFunction(this._mapOption.onStart)) {                     this._mapOption.onStart();                 }                 this._mapObject = new google.maps.Map($mapElement, {                     center: new google.maps.LatLng(this._mapOption.centerLatitude, this._mapOption.centerLongitude),                     zoom: this._mapOption.zoom,                     mapTypeId: gsa.util.TypeCasting.toGoogleMapsMapTypeId(this._mapOption.mapTypeId),                     zoomControlOptions: {                         style: gsa.util.TypeCasting.toGoogleMapsZoomControlStyle(this._mapOption.zoomControlStyle),                         position: gsa.util.TypeCasting.toGoogleMapsControlPosition(this._mapOption.zoomControlPosition)                     },                     mapTypeControl: false,                     zoomControl: true,                     panControl: false,                 });                                //clickable for set point                 if (this._mapOption.setPointable) {                     var marker = new google.maps.Marker({                         map: this._mapObject,                         icon: util.UrlHelper.getInstance().getMyLocationMarkerIcon(),                         animation: google.maps.Animation.BOUNCE                     });                     var infowindow = new google.maps.InfoWindow({                         content: this._mapOption.setPointTemplate                     });                     google.maps.event.addListener(this._mapObject, 'click', (event) => {                         marker.setPosition(event.latLng);                         infowindow.close();                         infowindow.open(this._mapObject, marker);                         this._mapOption.onSetPoint(new LatLng(event.latLng.lat(), event.latLng.lng()));                     });                 }                 return new Markers(this._mapObject, this._mapOption);             }             catch (e) {                 if (gsa.util.FunctionUtility.isFunction(this._mapOption.onError)) {                     this._mapOption.onError((<Error>e).message);                 }                 throw new Error((<Error>e).toString());             }             finally {                 google.maps.event.addListener(this._mapObject, 'tilesloaded', () => {                     if (gsa.util.FunctionUtility.isFunction(this._mapOption.onComplete)) {                         this._mapOption.onComplete();                     }                 });             }         }     }      export class Markers {         private static _infoWindow: google.maps.InfoWindow = new google.maps.InfoWindow();         public static _instance: Markers;         private _mapMarkers: Array<google.maps.Marker> = new Array<google.maps.Marker>();         public _mylocationPoint: LatLng;          constructor(private _mapObject: google.maps.Map, private _mapOption: MapOption) {             console.log('Markers.ctor');             Markers._instance = this;             //get all markers with key and call addMarkerToMap()             for (var item: number = 0; item < (this._mapOption.keys ? this._mapOption.keys.length : 0); item++) {                 gsa.net.RemoteService.SendRequest(                     {                         url: gsa.util.UrlHelper.getInstance().getMarkers(this._mapOption.keys[item].key),                         type: "get",                         async: true,                         dataType: "json",                         crossDomain: true,                         cache: true,                         success: (response: FetchMarkers) => {                             this.addMarkerToMap(response, this._mapOption.findIndexKey(response.MarkerConfiguration.Key));                         }                     });             }          }          public setCenterPoint(point: LatLng): Markers {             if (point == null || typeof (point) == 'undefined') throw new bcl.MapOptionException(40405);             this._mapObject.setCenter(gsa.util.TypeCasting.toGoogleMapsLatLngObject(point));             return this;         }         public setMyLocation(markersOption: MarkersOptions): Markers {             if (markersOption.position == null)                 throw new bcl.MapOptionException(50001);             this._mylocationPoint = markersOption.position;             var mylocationMarker = new google.maps.Marker({                 position: gsa.util.TypeCasting.toGoogleMapsLatLngObject(markersOption.position),                 clickable: markersOption.clickable,                 icon: markersOption.icon || util.UrlHelper.getInstance().getMyLocationMarkerIcon(),                 draggable: markersOption.dragable,                 raiseOnDrag: markersOption.raiseOnDrag,                 visible: markersOption.visible,             });             if (typeof markersOption != 'undefined' && markersOption.clickable == true) {                 google.maps.event.addListener(mylocationMarker, 'click', () => {                     Markers._infoWindow.close();                     Markers._infoWindow.setContent(markersOption.template ? markersOption.template() : TemplateManagment.myLocationTemplate());                     Markers._infoWindow.open(this._mapObject, mylocationMarker);                 });             }             mylocationMarker.setMap(this._mapObject);             return this;         }         public openInfoWindow(point: LatLng): Markers {             if (point == null || typeof (point) == "undefined") throw new bcl.MapOptionException(40405);             var l = this._mapMarkers.length;             var googlePoint: google.maps.LatLng = util.TypeCasting.toGoogleMapsLatLngObject(point);             for (var i = 0; i < l - 1; i++)                 if (this._mapMarkers[i].getPosition().equals(googlePoint)) {                     var marker = this._mapMarkers[i];                     Markers._infoWindow.close();                     Markers._infoWindow.setOptions({ maxWidth: 300 });                     Markers._infoWindow.setContent(marker.template);                     Markers._infoWindow.open(this._mapObject, marker);                 }             return this;         }         public addMarkerToMap(fetchMarkers: FetchMarkers, index: number): void {             var compiler: util.StringInterpolation = new util.StringInterpolation(this._mapOption.keys[index].template ? this._mapOption.keys[index].template() : KeyStore.getKey(this._mapOption.keys[index].key).template());             for (var i: number = 0; i < fetchMarkers.MarkerData.length; i++) {                 var item = fetchMarkers.MarkerData[i];                 var marker: google.maps.Marker = new google.maps.Marker({                     position: new google.maps.LatLng(item.Latitude, item.Longitude),                     icon: fetchMarkers.MarkerConfiguration.IconAddress,                     map: this._mapObject,                     template: compiler.render(item),                     key: fetchMarkers.MarkerConfiguration.Key                 });                 google.maps.event.addListener(marker, 'click', function () {                     Markers._infoWindow.close();                     Markers._infoWindow.setOptions({ maxWidth: 300 });                     Markers._infoWindow.setContent(this.template);                     Markers._infoWindow.open(this.map, this);                 });                 this._mapMarkers.push(marker);             }             CacheMarkers.getInstance().listFetchMarkers.push(fetchMarkers);         }          public changeStateMarkers(key: string, visible: boolean): Markers {             var cacheMarkers: CacheMarkers = maps.CacheMarkers.getInstance();             for (var index: number = 0; index < cacheMarkers.listFetchMarkers.length; index++) {                 if (cacheMarkers.listFetchMarkers[index].MarkerConfiguration.Key == key) {                     cacheMarkers.listFetchMarkers[index].MarkerConfiguration.Active = visible;                 }             }             if (visible) {                 for (var index: number = 0; index < this._mapMarkers.length; index++) {                     if (this._mapMarkers[index].getMap() == null && this._mapMarkers[index].key == key)                         this._mapMarkers[index].setMap(this._mapObject)                 }             } else {                 for (var index: number = 0; index < this._mapMarkers.length; index++) {                     if (this._mapMarkers[index].key == key)                         this._mapMarkers[index].setMap(null);                 }             }              return this;         }     }      export interface MarkersOptions {         clickable?: boolean;         icon?: string;         position?: LatLng;         dragable?: boolean;         raiseOnDrag?: boolean;         visible?: boolean;         template: () => string;     }      export class CacheMarkers {         private static _instance: CacheMarkers = new CacheMarkers();         constructor() {             if (CacheMarkers._instance) {                 throw new Error("Error: Instantiation failed: Use UrlHelper.getInstance() instead of new.");             }             CacheMarkers._instance = this;         }         public resetCache(): void {             this.listFetchMarkers = new Array<FetchMarkers>();         }         public static getInstance(): CacheMarkers {             return CacheMarkers._instance;         }         public listFetchMarkers: Array<FetchMarkers> = new Array<FetchMarkers>();         public getAllKey(): Array<string> {             var keys: Array<string> = [];             for (var index: number = 0; index < this.listFetchMarkers.length; index++) {                 keys.push(this.listFetchMarkers[index].MarkerConfiguration.Key);             }             return keys;         }     }     export class FetchMarkers {         public MarkerConfiguration: MarkerConfiguration;         public MarkerData: Array<MarkerData>;     }     class MarkerConfiguration {         public Key: string;         public KeyFa: string;         public IconAddress: string;         public Active: boolean;     }     /**      * Marker data is a data transfer object between layers also transfer between client and server      */     export class MarkerData {         public Latitude: number;         public Longitude: number;         public FirstName: string;         public LastName: string;         public Address: string;         public Tel: string;         public PartyType: string;         public Code: string;     }          //******************************** Map Base Class Library ***************************************//     export class LatLng {         constructor(public lat: number, public lng: number) { };         public toUrlValue(): string {             return "lat=" + this.lat.toString() + "&lng=" + this.lng.toString();         };     }     class TemplateManagment {         static myLocationTemplate(): string {             return "<div class='MarkerContent'>موقعیت فعلی شما</div>"         };         static defaulAgency(): string {             return document.getElementById("defaultAgency").innerHTML;         }     }  }    //-------------------------- linq interface Array<T> {     where(predicate, context?): Array<T>;     take(count: number, context?): Array<T>;     first(): Array<T>;  } Array.prototype.where = function (predicate, context?): any[] {     context = context || window;     var arr = [];     var l = this.length;     for (var i = 0; i < l; i++)         if (predicate.call(context, this[i], i, this) === true)             arr.push(this[i]);     return arr;  };  Array.prototype.take = function (count, context?) {     return context.slice(0, count);  };